from Crypto.Util.number import *

def findRoot5(n):
    l = 0
    r = n
    ans = 1
    while l <= r:
        mid = (l + r) // 2
        if mid ** 5 <= n: # p with math prove is 5
            ans = mid
            l = mid + 1
        else:
            r = mid - 1
    return ans

# Default input
n = 117378567124716236236044558241107806605736253057406303459584977215087315697749662980445901987640185615597015856640181841784590874624712744033616578986059075120813449396552360882943977036587199937478038256465488814670708953070327618634265180619676128267728587071877304192349209279829117836107480980367456989279
c = 108817996478875962748807685195898839235131415400466830502524210777425827093704229959538255915222443323086499960850671889776307310138913352257135472558586384613496645120303258236012657365786485202270513426542985835132081706816259242122683220830902241445129137922342680575714428880320859445026342129240966744206
e = 0x10001

# Decryption

p = findRoot5(n*n//4)
print(p)
ansp = 0
ansq = 0

for p_dutinh in range(p - 100000, p + 100000):
    if (n % p_dutinh == 0):
        ansp = p_dutinh
        ansq = n // p_dutinh

# Google search: RSA modulus factorization
phi = (ansp - 1) * (ansq - 1)
d = pow(e, -1, phi)
m = pow(c, d, n)

print(long_to_bytes(m))